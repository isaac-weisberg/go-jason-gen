package main

import (
	"fmt"
	"go/ast"
	"go/token"
	"os"
	"path"
	"strings"

	packages "golang.org/x/tools/go/packages"
)

func main() {
	var packageLocation = "./sample"

	var thePackage, err = loadPackage(packageLocation)

	if err != nil {
		panic(err)
	}

	err = traverseThePackage(packageLocation, thePackage)
	if err != nil {
		panic(err)
	}
}

type FirstClassField struct {
	name      string
	fieldType string
}

type StructDeclaration struct {
	structName       string
	firstClassFields []FirstClassField
}

func traverseThePackage(packageLocation string, thePackage *packages.Package) error {
	var structDeclarations = make([]StructDeclaration, 0)

	for _, file := range thePackage.Syntax {
		ast.Inspect(file, func(node ast.Node) bool {
			declaration, ok := node.(*ast.GenDecl)
			if !ok {
				return true
			}

			if declaration.Tok != token.TYPE {
				return true
			}

			for _, spec := range declaration.Specs {
				var typeSpec = spec.(*ast.TypeSpec) // succeeds, always

				var structType, ok = typeSpec.Type.(*ast.StructType)
				if !ok {
					panic("cant generate for anything but structs")
				}

				var firstClassFields = make([]FirstClassField, 0)
				var metGojasonDecodable = false

				for _, field := range structType.Fields.List {
					fieldTypeAsIdent, ok := field.Type.(*ast.Ident)
					if ok {
						hasName := len(field.Names) > 0

						if hasName {
							name := field.Names[0].Name

							var firstClassField = FirstClassField{
								name:      name,
								fieldType: fieldTypeAsIdent.Name,
							}
							firstClassFields = append(firstClassFields, firstClassField)
						}

						continue
					}

					fieldTypeAsSelector, ok := field.Type.(*ast.SelectorExpr)
					if ok {
						xAsIdent, ok := fieldTypeAsSelector.X.(*ast.Ident)
						if ok {
							if xAsIdent.Name == "gojason" && fieldTypeAsSelector.Sel.Name == "Decodable" {
								metGojasonDecodable = true
							}
						}
					}

				}

				if metGojasonDecodable {
					var structDeclaration = StructDeclaration{
						structName:       typeSpec.Name.Name,
						firstClassFields: firstClassFields,
					}
					structDeclarations = append(structDeclarations, structDeclaration)
				}
			}

			return false
		})
	}

	var packageName = thePackage.Name
	generateForStructDeclarations(packageName, packageLocation, structDeclarations)

	return nil
}

func loadPackage(locationPattern string) (*packages.Package, error) {
	var tags = make([]string, 0)
	var loadConfig = packages.Config{
		Mode:       packages.NeedName | packages.NeedTypes | packages.NeedTypesInfo | packages.NeedSyntax,
		Tests:      false,
		BuildFlags: []string{fmt.Sprintf("-tags=%s", strings.Join(tags, " "))},
	}

	var packages, err = packages.Load(&loadConfig, locationPattern)
	if err != nil {
		return nil, w(err, "load packages failed")
	}

	if len(packages) == 0 {
		return nil, e("found no packages")
	}

	if len(packages) > 1 {
		return nil, e("found more than one package")
	}

	var firstPackage = packages[0]

	return firstPackage, nil
}

func contains[T comparable](s []T, e T) bool {
	for _, a := range s {
		if a == e {
			return true
		}
	}
	return false
}

func generateForStructDeclarations(packageName string, packageLocation string, structDeclarations []StructDeclaration) {
	var builder customBuilder

	builder.WriteLine("// Code generated by \"go-jason-gen\"; DO NOT EDIT.")
	builder.WriteLine()
	builder.WriteLine("package ", packageName)
	builder.WriteLine()

	if len(structDeclarations) > 0 {
		builder.WriteLine("import (")
		builder.WriteLineIndent(1, `"errors"`)
		builder.WriteLine()
		builder.WriteLineIndent(1, `gojason "github.com/isaac-weisberg/go-jason"`)
		builder.WriteLineIndent(1, `values "github.com/isaac-weisberg/go-jason/values"`)
		builder.WriteLine(")")
		builder.WriteLine()
	}

	for _, declaration := range structDeclarations {
		var structName = declaration.structName
		var structNameCapitalized = firstCapitalized(structName)

		builder.WriteLineFI(0, "func make%sFromJson(bytes []byte) (*%s, error) {", structNameCapitalized, structName)

		builder.WriteLineIndent(1, "var j = errors.Join")
		builder.WriteLineIndent(1, "var e = errors.New")
		builder.WriteLine()
		builder.WriteLineIndent(1, "rootValueAny, err := gojason.Parse(bytes)")
		builder.WriteLineIndent(1, "if err != nil {")
		builder.WriteLineIndent(2, `return nil, j(e("parsing json into an object tree failed"), err)`)
		builder.WriteLineIndent(1, "}")
		builder.WriteLine()
		builder.WriteLineIndent(1, "rootObject, err := rootValueAny.AsObject()")
		builder.WriteLineIndent(1, "if err != nil {")
		builder.WriteLineIndent(2, `return nil, j(e("interpreting root json value as an object failed"), err)`)
		builder.WriteLineIndent(1, "}")
		builder.WriteLine()
		builder.WriteLineIndent(1, "parsedObject, err := parseAddMoneyRequestFromJsonObject(rootObject)")
		builder.WriteLineIndent(1, "if err != nil {")
		builder.WriteLineIndent(2, `return nil, j(e("parsing json into the resulting value failed"), err)`)
		builder.WriteLineIndent(1, "}")
		builder.WriteLine()
		builder.WriteLineIndent(1, "return parsedObject, nil")
		builder.WriteLine("}")
		builder.WriteLine()

		builder.WriteLineFI(0, "func parse%sFromJson(rootObject *values.JsonValueObject) (*%s, error) {", structNameCapitalized, structName)
		builder.WriteLineIndent(1, "var j = errors.Join")
		builder.WriteLineIndent(1, "var e = errors.New")
		builder.WriteLine()
		builder.WriteLineIndent(1, "var stringKeyValues = rootObject.StringKeyedKeyValuesOnly()")
		builder.WriteLine()

		type InitializationValue struct {
			valueName          string
			needsDereferencing bool
		}

		var keysAndValuesForThem = make(map[string]InitializationValue, 0)

		for _, firstClassField := range declaration.firstClassFields {
			var fieldName = firstClassField.name
			var fieldNameCapitalized = firstCapitalized(fieldName)

			builder.WriteLineFI(1, `valueFor%sKey, exists := stringKeyValues["%s"]`, fieldNameCapitalized, fieldName)
			builder.WriteLineFI(1, `if !exists {`)
			builder.WriteLineFI(2, `return nil, j(e("value not found for key '%s'"))`, fieldName)
			builder.WriteLineFI(1, "}")

			var jsonObjectOfInterest = detectWhatJsonObjectShouldBeParsedForType(firstClassField.fieldType)

			switch jsonObjectOfInterest {
			case JsonObjectOfInterestInt64:
				builder.WriteLineFI(1, `valueFor%sKeyAsNumberValue, err := valueFor%sKey.AsNumber()`, fieldNameCapitalized, fieldNameCapitalized)
				builder.WriteLineFI(1, `if err != nil {`)
				builder.WriteLineFI(2, `return nil, j(e("interpreting JsonAny as Number failed for key '%s'"), err)`, fieldName)
				builder.WriteLineFI(1, `}`)

				var resultingValueName = fmt.Sprintf(`parsedInt64For%sKey`, fieldNameCapitalized)

				builder.WriteLineFI(1, `%s, err := valueFor%sKeyAsNumberValue.ParseInt64()`, resultingValueName, fieldNameCapitalized)
				builder.WriteLineFI(1, `if err != nil {`)
				builder.WriteLineFI(2, `return nil, j(e("parsing int64 from Number failed for key '%s'"), err)`, fieldName)
				builder.WriteLineFI(1, `}`)

				keysAndValuesForThem[fieldName] = InitializationValue{
					valueName:          resultingValueName,
					needsDereferencing: true,
				}
			case JsonObjectOfInterestString:
				builder.WriteLineFI(1, `valueFor%sKeyAsStringValue, err := valueFor%sKey.AsString()`, fieldNameCapitalized, fieldNameCapitalized)
				builder.WriteLineFI(1, `if err != nil {`)
				builder.WriteLineFI(2, `return nil, j(e("interpreting JsonAny as String failed for key '%s'"), err)`, fieldName)
				builder.WriteLineFI(1, `}`)

				var resultingValueName = fmt.Sprintf(`parsedStringFor%sKey`, fieldNameCapitalized)

				builder.WriteLineFI(1, `%s := valueFor%sKeyAsStringValue.String`, resultingValueName, fieldNameCapitalized)

				keysAndValuesForThem[fieldName] = InitializationValue{
					valueName:          resultingValueName,
					needsDereferencing: false,
				}
			default:
				panic("not supposed to happen")
			}

			builder.WriteLine()
		}

		builder.WriteLineFI(1, `var decodable = gojason.Decodable{}`)
		builder.WriteLineFI(1, `var resultingStruct%s = %s{`, structNameCapitalized, declaration.structName)
		builder.WriteLineFI(2, `Decodable: decodable,`)
		for k, value := range keysAndValuesForThem {
			var formatStringRepresentingUsageOfValue string
			if value.needsDereferencing {
				formatStringRepresentingUsageOfValue = "*%s"
			} else {
				formatStringRepresentingUsageOfValue = "%s"
			}
			var valueUsage = fmt.Sprintf(formatStringRepresentingUsageOfValue, value.valueName)
			builder.WriteLineFI(2, `%s: %s,`, k, valueUsage)
		}
		builder.WriteLineFI(1, `}`)
		builder.WriteLineFI(1, `return &resultingStruct%s, nil`, structNameCapitalized)
		builder.WriteLine("}")
	}

	var result = builder.String()

	fmt.Printf("\n%s\n", result)

	fileNameToWrite := "go_jason_generated.go"
	filePathToWrite := path.Join(packageLocation, fileNameToWrite)

	os.WriteFile(filePathToWrite, []byte(result), 0644)
}

type JsonObjectOfInterest int64

const (
	JsonObjectOfInterestInvalido JsonObjectOfInterest = iota
	JsonObjectOfInterestInt64
	JsonObjectOfInterestString
	JsonObjectOfInterestAnotherType
)

func detectWhatJsonObjectShouldBeParsedForType(t string) JsonObjectOfInterest {
	switch t {
	case "int64":
		return JsonObjectOfInterestInt64
	case "string":
		return JsonObjectOfInterestString
	default:
		return JsonObjectOfInterestAnotherType
	}
}
